package v1alpha1

import (
	"errors"
	"slices"

	"github.com/neuvector/runtime-enforcer/internal/types/policymode"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	// PolicyProposalMaxExecutables defines the maximum number of executables that we can learn.
	// This is a arbitrary number right now and can be fine-tuned or made configurable in the future.
	PolicyProposalMaxExecutables = 100
	ApprovalLabelKey             = "security.rancher.io/policy-ready"
	PolicyLabelKey               = "security.rancher.io/policy"
)

// WorkloadPolicyProposalSpec defines the desired state of WorkloadPolicyProposal.
type WorkloadPolicyProposalSpec struct {

	// rulesByContainer specifies for each container the list of rules to apply.
	RulesByContainer map[string]*WorkloadPolicyRules `json:"rulesByContainer,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// WorkloadPolicyProposal is the Schema for the workloadpolicyproposals API.
type WorkloadPolicyProposal struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec WorkloadPolicyProposalSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// WorkloadPolicyProposalList contains a list of WorkloadPolicyProposal.
type WorkloadPolicyProposalList struct {
	metav1.TypeMeta `json:",inline"`

	metav1.ListMeta `json:"metadata,omitempty"`

	Items []WorkloadPolicyProposal `json:"items"`
}

func (p *WorkloadPolicyProposal) getExecutablesLength() int {
	if p.Spec.RulesByContainer == nil {
		return 0
	}

	result := 0
	for _, value := range p.Spec.RulesByContainer {
		result += len(value.Executables.Allowed)
	}

	return result
}

func (p *WorkloadPolicyProposal) AddProcess(containerName string, executable string) error {
	if p.getExecutablesLength() >= PolicyProposalMaxExecutables {
		return errors.New("the number of executables has exceeded its maximum")
	}

	if p.Spec.RulesByContainer == nil {
		p.Spec.RulesByContainer = make(map[string]*WorkloadPolicyRules)
	}

	rules, ok := p.Spec.RulesByContainer[containerName]
	if !ok {
		p.Spec.RulesByContainer[containerName] = &WorkloadPolicyRules{
			Executables: WorkloadPolicyExecutables{
				Allowed: []string{executable},
			},
		}
		return nil
	}

	if slices.Contains(rules.Executables.Allowed, executable) {
		return nil
	}

	rules.Executables.Allowed = append(rules.Executables.Allowed, executable)

	return nil
}

func (p *WorkloadPolicyProposal) AddPartialOwnerReferenceDetails(workloadKind string, workload string) {
	p.OwnerReferences = []metav1.OwnerReference{
		{
			Kind: workloadKind,
			Name: workload,
		},
	}
}

func (p *WorkloadPolicyProposalSpec) IntoWorkloadPolicySpec() WorkloadPolicySpec {
	// enforcement mode to "monitor" by default.
	return WorkloadPolicySpec{
		Mode:             policymode.MonitorString,
		RulesByContainer: p.RulesByContainer,
	}
}

//nolint:gochecknoinits // Generated by kubebuilder
func init() {
	SchemeBuilder.Register(&WorkloadPolicyProposal{}, &WorkloadPolicyProposalList{})
}
