= Runtime Enforcer phases: learn, monitor, protect

This document explains the three *phases* of runtime-enforcer and how to move between them.

== Quick mapping to CRDs

* *Learn phase*: the system observes process executions and creates/updates `WorkloadPolicyProposal` objects.
* *Monitor phase*: a `WorkloadPolicy` exists with `.spec.mode: monitor` (violations are reported, not blocked).
* *Protect phase*: a `WorkloadPolicy` exists with `.spec.mode: protect` (violations are reported and blocked).

Important: the `WorkloadPolicy` CRD only supports `monitor` and `protect` (`.spec.mode`). `Learn` is implemented as `WorkloadPolicyProposal` generation.

== Learn phase

=== What happens during this phase

* *Processes are not blocked.*
* Runtime-enforcer observes process executions in your workloads and learns the executable paths that run.
* For each learned executable, runtime-enforcer creates or updates a `WorkloadPolicyProposal` in the workload namespace and adds the executable path under `.spec.rulesByContainer[CONTAINER_NAME].executables.allowed`.


NOTE: Learn is based on *exec events observed after the agent is running*. The daemon does *not* reconstruct what happened before it started.

That means:

* If a workload was already running before runtime-enforcer started, *we cannot automatically propose the full set of processes it already executed in the past*.
* You will only learn processes that exec after runtime-enforcer is running (for long-lived pods that rarely exec, you may learn little or nothing until a restart or activity happens).

Operationally, if you want complete proposals, enable learning first and then *(re)start* the workloads you want to learn.

=== How to enter and leave the `Learn` phase

* *Enter*
** Ensure learning is enabled on the daemon:
*** Helm: `values.learning.enabled: true` (adds `--enable-learning` to the DaemonSet)
*** Or run the daemon with `--enable-learning`
** No per-workload configuration is required to start generating proposals (proposals are created as exec events are observed).
* *Leave*
** Mark the corresponding proposal as ready by setting the label: `security.rancher.io/policy-ready=true`
** This triggers creation of a `WorkloadPolicy` (defaulting to `mode: monitor`) and gets the proposal to be deleted.

=== CRDs created/updated during this phase

* *Created/updated*: `WorkloadPolicyProposal` (`security.rancher.io/v1alpha1`)
** Name format is derived from workload kind/name (for example `deploy-NAME`, `ds-NAME`, etc.).
** A mutating webhook completes the proposal’s `ownerReferences` and fills `.spec.selector` from the owning workload’s selector when possible.

== Monitor phase

=== What happens during this phase

* *Processes are not blocked.*
* Enforcement is active for workloads that are bound to the policy.
* When a process exec is *not on the allow-list* for the container:
** the exec is *allowed*
** a *violation* event is emitted and exported via OpenTelemetry with `action=monitor`.

=== How to enter and leave the phase

* *Enter*
** A `WorkloadPolicy` is created (usually by approving a proposal), and ensure it has:
*** `.spec.mode: monitor`
*** `.spec.rulesByContainer` populated with allowed executables per container name
** Bind workloads/pods to the policy by applying the label: `security.rancher.io/policy: WORKLOAD_POLICY_NAME`
+
Runtime-enforcer uses this label to decide which pods the policy applies to.

* *Leave*
** *Monitor → Protect*: update the `WorkloadPolicy` and set `.spec.mode: protect`.
** *Monitor → Learn*: remove the `security.rancher.io/policy` label from workloads/pods, then delete the `WorkloadPolicy`.
*** Note: `WorkloadPolicy` has a finalizer and will not be deleted while pods still reference it via the label.

=== CRDs created/updated during this phase

* *Used/updated*: `WorkloadPolicy`
** `.spec.mode` controls whether violations are blocked (`protect`) or allowed (`monitor`).
** A mutating webhook adds a finalizer (`workloadpolicy.security.rancher.io/finalizer`) so policies cannot be deleted while in use.

== Protect phase

=== What happens during this phase

* *Processes are blocked* when they violate the allow-list.
* On an attempted exec that is not allowed:
** a *violation* event is emitted (same as monitor, but with `action=protect`)
** the exec fails, which typically appears as *“Permission denied”* in the container/process
** the process does not start; depending on what was blocked this can cause application errors, crash loops, or failed jobs.

=== How to enter and leave the phase

* *Enter*
** Ensure the workload is bound via `security.rancher.io/policy: WORKLOAD_POLICY_NAME`.
** Update the `WorkloadPolicy` to set `.spec.mode: protect`.
* *Leave*
** *Protect → Monitor*: set `.spec.mode: monitor`.
** *Protect → Learn*: remove the binding label from workloads/pods, then delete the `WorkloadPolicy` (finalizer will delay deletion until no pods reference it).

=== CRDs created/updated during this phase

* *Used/updated*: `WorkloadPolicy` (same CRD as monitor; only `.spec.mode` changes).
